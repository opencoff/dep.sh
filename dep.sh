#! /usr/bin/env bash

# Shell implementation of a simple golang vendor management tool.
# Tries to implement same commands as "dep"; this existed before dep
# was talked about.
#
# CAVEAT: It only knows how to handle git upstream vendors.
#
# (c) 2016 Sudhi Herle <sudhi-at-herle-net>
# License: GPLv2
#
# Usage: $0 --help
#

Z=`basename $0`
PWD=`pwd`

Dryrun=0
Debug=0
Verbose=0
Gitquiet="-q"
Arch=
Nogit=0
e=

#set -e

die() {
    echo "$Z: $@" 1>&2
    exit 0
}

case $BASH_VERSION in
    4.*.*) ;;

    *) die "I need bash 4.x to run!"
        ;;
esac

warn() {
    echo "$Z: $@" 1>&2
}

progress() {
    [ $Verbose -gt 0 ] && echo "$@"
    return 0
}


gitx() {
    if [ $Nogit -eq 0 ]; then
        $e git "$@"
        return $?
    fi
    return 0
}


# show usage and quit
usage() {
    cat <<EOF
$Z - An simple golang vendor dependency management tool.

Usage: $Z [options] COMMAND [command-options]

$Z knows the following commands:

init
    Initialize the current directory with necessary bits for vendor
    dependency management.

fetch|get  repo [tag]
    Run "go get" on the remote REPO and record it in the manifest.
    If the optional TAG is specified, update the vendor repo to that
    specific version.

update  repo [tag]
update  --all
    In the first mode, update one particular repo with the latest
    upstream contents. Optionally, one can pin the update to a
    specific TAG. This pinned tag is recorded in the vendor
    manifest.
    In the second mode, update all repositories.

ensure, sync
    Checkout all the repositories in the manifest and initialize a local
    copy of the pinned, vendored repositories. Remember to run this
    whenever you switch branches (git/hg).

rebuild
    Rebuild the manifest from the contents in the vendor directory. 
    This command is useful when you have carefully pinned vendor
    repositories.

status, list
    Show a list of vendored and pinned repositories.

help
    Show this help message and quit.

The remote repositories are recorded in 'vendor/manifest.txt'.

NB: $Z only knows to handle upstream git vendor repositories.

Global options:
---------------
--help, -h      Show this help message and quit
--verbose, -v   Run in verbose mode [False]
--dry-run       Run in dry-run mode (do not modify disk) [False]
--no-git, -N    Don't run any 'git add' commands [False]
--debug, -x     Run the tool in "debug mode" [False]
EOF
    exit 0
}


# Update manifest if it hasn't changed.
maybe_update_manifest() {
    local mf=$1
    local new=$2
    local old=$mf.orig.$$.$RANDOM
    local mftmp=$mf.tmp.$$.$RANDOM

    grep -v '#' $mf > $old
    if cmp -s $old $new; then
        rm -f $old $new
        return 1
    fi

    cat > $mftmp <<EOFx
# Vendor manifest; Automatically generated by $0
# Last-Updated: `date`
#
EOFx
    [ -s $new ] && cat $new >> $mftmp
    $e mv $mftmp $mf
    rm -f $old $new $mftmp
    return 0
}


# Fetch a new git repo and add to manifest
#
# fetch /abspath/to/vendor REPO [update]
fetch() {
    local vendor=$1
    local repo=$2
    local ver=$3
    local targ=$vendor/src/$repo
    local upd=
    local verb=

    [ $Verbose -gt 0 ] && verb="-v"
    progress "Fetching $repo .."

    # 'go get' will fetch $repo and all its dependencies.
    # Everything it fetches will be placed under vendor/
    $e env GOPATH=$vendor go get $verb -d $repo || exit 1

    rebuild_manifest $vendor

    # if the user desires a specific version, make it so
    if [ -n "$ver" ]; then
        update_one $vendor $repo $ver
    fi

}


# Rebuild the manifest from the pinned versions in the vendor dir.
# rebuild_mainfest relpath_to_vendor
rebuild_manifest() {
    local vend=$1
    local rr=
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM

    (cd $PWD;
    find $vend/src -name '.git' -type d | sort | \
        while read rr; do
            rr=$(dirname $rr)
            (
                cd $rr

                local repo=$(echo $rr | sed -e "s!^$vend/src/!!")
                local v=$(git describe --always --abbrev=64)
                local u=$(git config --get remote.origin.url)

                echo "$repo $v $u" >> $mftmp
            )
        done

    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf || exit 1
    fi
    )

    return 0
}


# Upgrade old manifest to a new style
upgrade_old() {
    local vend=$1
    local rr=
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM

    grep -v '#' $mf | \
        while read line; do
            set -- $line
            local z=$1
            local u=$2
            local v=$3

            echo "$z $v $u" >> $mftmp
        done || exit 1

    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf || exit 1
    fi

    return 0
}

# update all the sub-modules and generate a new manifest.
# NB: This implicitly fetches the latest upstream HEAD.
# update_all /abs/path/to/vendor
update_all() {
    local vend=$1
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM
    local wd=$PWD

    [ -f $mf ] || die "No vendor repositories (no manifest)"

    grep -v '#' $mf | \
        while read line; do
            set -- $line
            local z=$1
            local v=$2
            local u=$3
            local oldv=$v

            cd $vend/src/$z

            # XXX We always assume git
            $e git pull $Gitquiet origin master || exit 1
            $e git checkout $Gitquiet master    || exit 1
            v=$(git describe --always --abbrev=64)
            if [ $v = $oldv ]; then
                progress "$z: No upstream changes; staying at $v .."
            else
                progress "$z: Updated to $v .."
            fi

            echo "$z $v $u" >> $mftmp
        done || exit 1

    cd $wd
    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf || exit 1
    fi
    return 0
}


# Update One sub-module and re-generate the manifest
# update_one /path/to/vendor repo_name [pinned_version]
update_one() {
    local vend=$1
    local repo=$2       # relative repo name
    local tag=$3        # specific tag/sha [can be empty]
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM
    local wd=$PWD

    [ -f $mf ]    || die "No vendor repositories (no manifest)"
    [ -n "$tag" ] || tag="master"

    grep -v '#' $mf | \
        while read line; do
            set -- $line
            local z=$1
            local v=$2
            local u=$3
            local oldv=$v

            if [ $z != $repo ]; then
                echo "$line" >> $mftmp
                continue
            fi

            # Update this repo
            cd $vend/src/$repo
            $e git pull  $Gitquiet origin master || exit 1
            $e git checkout $Gitquiet $tag       || exit 1
            v=$(git describe --always --abbrev=64)
            cd $wd
            if [ $v = $oldv ]; then
                progress "$z: No upstream changes; staying at $v .."
            else
                progress "$z: Updated to $v .."
            fi

            echo "$z $v $u" >> $mftmp
        done || exit 1

    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf || exit 1
    fi
    return 0
}

# git-pull all repositories in the manifest and setup a local copy
# of the vendored repos.
sync_all() {
    local vend=$1
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM
    local wd=$PWD

    [ -f $mf ] || die "No vendor repositories (no manifest)"

    grep -v '#' $mf | \
        while read line; do
            set -- $line
            local z=$1
            local v=$2
            local u=$3

            [ -z "$v" ] && v=HEAD

            local d=$vend/src/$z

            (
              if [ -d $d/.git ]; then
                  cd $d
                  local cv=$(git describe --always --abbrev=64)
                  [ -z "$cv" ] && die "$z: git corrupted?"
                  if [ $cv = $v ]; then
                      progress "$z Repo already at $v; skipping .."
                  else
                      progress "$z: Moving from $cv to $v .."
                      $e git pull     $Gitquiet origin master && \
                      $e git checkout $Gitquiet $v
                  fi
              else
                  progress "$z: Cloning and checking out $v.."
                  $e rm -rf $d && mkdir -p $d && cd $d && \
                  $e git clone    $Gitquiet $u .       && \
                  $e git checkout $Gitquiet $v
              fi
            ) || exit 1
          echo "$z $v $u" >> $mftmp
        done || exit 1

    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf || exit 1
    fi
    return 0
}


# list vendored repositories
list_all() {
    local vend=$1
    local mf=$vend/manifest.txt

    [ -f $mf ] || die "No vendor repositories (no manifest)"

    grep -v '#' $mf | \
        while read line; do
            set -- $line
            local z=$1
            local v=$2
            local u=$3

            local d=$vend/src/$z

            (
              if [ -d $d/.git ]; then
                  cd $d
                  local cv=$(git describe --always --abbrev=64)
                  [ -z "$cv" ] && die "$z: git corrupted?"
                  if [ $cv = $v ]; then
                      echo "$z: up-to-date [$v]"
                  else
                      echo "$z: out-of-sync [manifest: $v, repo: $cv]"
                  fi
              else
                  echo "$z: Missing repository. Run '$0 ensure'"
              fi
          ) || exit 1
      done || exit 1
    return 0
}


# initialize and setup for vendor management
init_repo() {
    [ -d $PWD/src ]        || mkdir -p $PWD/src
    [ -d $PWD/vendor/src ] || mkdir -p $PWD/vendor/src

    touch vendor/manifest.txt
    ign=$PWD/.gitignore

    [ -f $ign ] || touch $ign
    if ! grep -q vendor/src $ign; then
        cat >> $ign <<EOFx

# gg vendor management
vendor/src/*
vendor/pkg/*
EOFx
    fi

    gitx add vendor/manifest.txt .gitignore || exit 1
    return 0
}


host=`uname|tr '[A-Z]' '[a-z]'`
export GO15VENDOREXPERIMENT=1

args=

#set -x
ac_prev=
for ac_option
do
  shift

  if [ -n "$ac_prev" ]; then
    eval "$ac_prev=\$ac_option"
    ac_prev=
    continue
  fi

  case "$ac_option" in
      -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
      *) ac_optarg= ;;
  esac


  case "$ac_option" in
        --help|-h|--hel|--he|--h)
            usage;
            ;;

        --dry-run)
            Dryrun=1
            ;;

        --no-git|-N)
            Nogit=1
            ;;

        --debug|-x)
            Debug=1
            ;;

        --verbose|-v)
            Verbose=1
            ;;

        *) # first non option terminates option processing.
           # we gather all remaining args and bundle them up.
            args="$args $ac_option"
            for xx
            do
                args="$args $xx"
            done
            break
            ;;
  esac
done

[ -d $PWD/.git      ] || Nogit=1
[ $Dryrun  -gt 0 ] && e=echo
[ $Verbose -gt 0 ] && Gitquiet=
[ $Debug   -gt 0 ] && set -x


vendor=$PWD/vendor
export GOPATH=$vendor:$PWD

set -- $args
cmd=$1; shift
case $cmd in

    init)
        init_repo
        exit 0
        ;;

    fetch|get)
        repo=$1
        tag=$2
        [ -n "$repo" ] || die "missing repo name for fetch"

        fetch $vendor $repo $tag
        ;;

    update)
        repo=$1
        tag=$2
        [ -n "$repo" ] || die "missing repo name for update"
        if [ "$repo" = "--all" ]; then
            update_all $vendor
        else
            update_one $vendor $repo $tag
        fi
        ;;

    rebuild)
        rebuild_manifest $vendor
        ;;

    sync|ensure)
        sync_all $vendor
        ;;

    list|status)
        list_all $vendor
        ;;

    help)
        usage
        ;;

    *)  # We just pass it off to go..
        die "Unknown command '$cmd'. Try '$Z --help'"
        ;;
esac
