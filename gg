#! /usr/bin/env bash

# Useful script to build go programs and manage vendor dependencies.
# It wraps the 'go' tool and augments its command vocabulary.
#
# This script knows how to cross-compile for various architectures
# without resorting to environment vars.
#
# In particular, this script supports:
#   o Cross compiling for Android  with the NDK toolchain
#   o Cross compiling for other OSes
#   o Vendor branch support (Go 1.5+)
#
# Cross compiling for Android requires the following magic:
#   o CGO_ENABLED=1
#   o CC=$NDK_CC
#
# (c) 2016 Sudhi Herle <sudhi-at-herle-net>
# License: GPLv2
#
# Usage: $0 --help
#

Z=`basename $0`
PWD=`pwd`

Dryrun=0
Debug=0
Verbose=0
Gitquiet="-q"
Arch=
Nogit=0
e=

#set -e

die() {
    echo "$Z: $@" 1>&2
    exit 0
}

case $BASH_VERSION in
    4.*.*) ;;

    *) die "I need bash 4.x to run!"
        ;;
esac

warn() {
    echo "$Z: $@" 1>&2
}

progress() {
    echo "$@"
    return 0
}


gitx() {
    if [ $Nogit -eq 0 ]; then
        $e git "$@"
        return $?
    fi
    return 0
}


# show usage and quit
usage() {
    cat <<EOF
$Z - An enhancement of 'go' tool to include hassle-free
vendor repo management and cross-compilation.

Usage: $Z [options] COMMAND [command-options]

In addition to the standard set of go commands, we support the
following additional commands:

fetch|get  repo
    Run "go get" on the remote REPO and record it in the manifest.

update  repo [tag]
update  --all
    In the first mode, update one particular repo with the latest
    upstream contents. Optionally, one can pin the update to a
    specific tag. This pinned tag is recorded in the vendor
    manifest.
    In the second mode, update all repositories.

sync
    Checkout all the repositories in the manifest and initialize a local
    copy of the pinned, vendored repositories. Remember to run this
    whenever you switch branches (git/hg).

rebuild
    Rebuild the manifest from the contents in the vendor directory. 
    This command is useful when you have carefully pinned vendor
    repositories.

list
    Show a list of vendored and pinned repositories.

The remote repositories are recorded in 'vendor/manifest.txt'.

Global options:
---------------
--help, -h      Show this help message and quit
--init          Initialize a directory with go 1.5+ conventions
--arch=X, -a X  Cross compile for architecture 'X'. An Arch is a
                combination of OS and CPU. e.g., android-arm64.
--dry-run       Run in dry-run mode (do not modify disk) [False]
--no-git, -N    Don't run any 'git add' commands [False]
--debug, -x     Run the tool in "debug mode" [False]
EOF
    exit 0
}


# Update manifest if it hasn't changed.
maybe_update_manifest() {
    local mf=$1
    local new=$2
    local old=$mf.orig.$$.$RANDOM
    local mftmp=$mf.tmp.$$.$RANDOM

    grep -v '#' $mf > $old
    if cmp -s $old $new; then
        rm -f $old $new
        return 1
    fi

    cat > $mftmp <<EOFx
# Vendor manifest; Automatically generated by $0
# Last-Updated: `date`
#
EOFx
    [ -s $new ] && cat $new >> $mftmp
    $e mv $mftmp $mf
    rm -f $old $new $mftmp
    return 0
}


# Fetch a new git repo and add to manifest
#
# fetch /abspath/to/vendor REPO [update]
fetch() {
    local vendor=$1
    local repo=$2
    local doupd=$3
    local targ=$vendor/src/$repo
    local upd=

    [ -n "$doupd" ] && upd="-u"

    progress "Fetching $repo .."

    # 'go get' will fetch $repo and all its dependencies.
    # Everything it fetches will be placed under vendor/
    $e env GOPATH=$vendor go get $upd $repo || exit 1

    rebuild_manifest $vendor
}


# Rebuild the manifest from the pinned versions in the vendor dir.
# rebuild_mainfest relpath_to_vendor
rebuild_manifest() {
    local vend=$1
    local rr=
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM

    (cd $PWD;
    find $vend/src -name '.git' -type d | sort | \
        while read rr; do
            rr=$(dirname $rr)
            (
                cd $rr

                local repo=$(echo $rr | sed -e "s!^$vend/src/!!")
                local u=$(git config --get remote.origin.url)
                local v=$(git describe --always --abbrev=64)

                echo "$repo $u $v" >> $mftmp
            )
        done

    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf
    fi
    )

    return 0
}


# update all the sub-modules and generate a new manifest.
# NB: This implicitly fetches the latest upstream HEAD.
# update_all /abs/path/to/vendor
update_all() {
    local vend=$1
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM
    local wd=$PWD

    [ -f $mf ] || die "No vendor repositories (no manifest)"

    grep -v '#' $mf | \
        while read line; do
            set -- $line
            local z=$1
            local u=$2
            local v=$3
            local oldv=$v

            cd $vend/src/$z

            # XXX We always assume git
            $e git pull $Gitquiet origin master || exit 1
            $e git checkout $Gitquiet master    || exit 1
            v=$(git describe --always --abbrev=64)
            if [ $v = $oldv ]; then
                progress "$z: No upstream changes; staying at $v .."
            else
                progress "$z: Updated to $v .."
            fi

            echo "$z $u $v" >> $mftmp
        done || exit 1

    cd $wd
    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf
    fi
    return 0
}


# Update One sub-module and re-generate the manifest
# update_one /path/to/vendor repo_name [pinned_version]
update_one() {
    local vend=$1
    local repo=$2       # relative repo name
    local tag=$3        # specific tag/sha [can be empty]
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM
    local wd=$PWD

    [ -f $mf ]    || die "No vendor repositories (no manifest)"
    [ -n "$tag" ] || tag="master"

    grep -v '#' $mf | \
        while read line; do
            set -- $line
            local z=$1
            local u=$2
            local v=$3
            local oldv=$v

            if [ $z != $repo ]; then
                echo "$line" >> $mftmp
                continue
            fi

            # Update this repo
            cd $vend/src/$repo
            $e git pull  $Gitquiet origin master || exit 1
            $e git checkout $Gitquiet $tag       || exit 1
            v=$(git describe --always --abbrev=64)
            cd $wd
            if [ $v = $oldv ]; then
                progress "$z: No upstream changes; staying at $v .."
            else
                progress "$z: Updated to $v .."
            fi

            echo "$z $u $v" >> $mftmp
        done || exit 1

    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf
    fi
    return 0
}

# git-pull all repositories in the manifest and setup a local copy
# of the vendored repos.
sync_all() {
    local vend=$1
    local mf=$vend/manifest.txt
    local mftmp=$mf.tmp.$$.$RANDOM
    local wd=$PWD

    [ -f $mf ] || die "No vendor repositories (no manifest)"

    grep -v '#' $mf | \
        while read line; do
            set -- $line
            local z=$1
            local u=$2
            local v=$3

            [ -z "$v" ] && v=HEAD

            local d=$vend/src/$z

            (
              if [ -d $d/.git ]; then
                  cd $d
                  local cv=$(git describe --always --abbrev=64)
                  if [ $cv = $v ]; then
                      progress "$z Repo already at $v; skipping .."
                  else
                      progress "$z: Moving from $cv to $v .."
                      $e git pull     $Gitquiet origin master && \
                      $e git checkout $Gitquiet $v
                  fi
              else
                  progress "$z: Cloning and checking out $v.."
                  $e rm -rf $d && mkdir -p $d && cd $d && \
                  $e git clone    $Gitquiet $u .       && \
                  $e git checkout $Gitquiet $v
              fi
            ) || exit 1
          echo "$z $u $v" >> $mftmp
        done || exit 1

    if maybe_update_manifest $mf $mftmp; then
        $e gitx add $mf
    fi
    return 0
}


# list vendored repositories
list_all() {
    local vend=$1
    local mf=$vend/manifest.txt

    [ -f $mf ] || die "No vendor repositories (no manifest)"

    grep -v '#' $mf
    return 0
}


host=`uname|tr '[A-Z]' '[a-z]'`
export GO15VENDOREXPERIMENT=1

declare -A oses
declare -A cpus
declare -A cgo

# Supported & Verified OS/CPU combos for this script
oslist="linux android openbsd freebsd darwin dragonfly netbsd"
needcgo="android"
cpulist="i386 amd64 arm arm64"
cpualias_i386="i486 i586 i686"
cpualias_amd64="x86_64"
cpualias_arm64="aarch64"

# CGO Compilers for various CPU+OS combinations
# We only note the android cross compilers here. For most other
# platforms, this script is rarely called to cross-compile..
android_i386=i686-linux-android-gcc
android_arm64=aarch64-linux-android-gcc
android_arm=arm-linux-androideabi-gcc

# initialize the various hash tables
for o in $oslist;  do oses[$o]=$o; done
for o in $needcgo; do cgo[$o]=$o;  done
for c in $cpulist; do
    cpus[$c]=$c
    a="cpualias_$c"
    a=${!a}
    for x in $a; do cpus[$x]=$c; done
done


doinit=0
args=

#set -x
ac_prev=
for ac_option
do
  shift

  if [ -n "$ac_prev" ]; then
    eval "$ac_prev=\$ac_option"
    ac_prev=
    continue
  fi

  case "$ac_option" in
      -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
      *) ac_optarg= ;;
  esac


  case "$ac_option" in
        --help|-h|--hel|--he|--h)
            usage;
            ;;

        --init)
            doinit=1
            ;;

        --arch=*)
            Arch=$ac_optarg
            ;;
        -a|--arch)
            ac_prev=Arch
            ;;

        --dry-run)
            Dryrun=1
            ;;

        --no-git|-N)
            Nogit=1
            ;;

        --debug|-x)
            Debug=1
            ;;

        --verbose|-v)
            Verbose=1
            ;;

        *) # first non option terminates option processing.
           # we gather all remaining args and bundle them up.
            args="$args $ac_option"
            for xx
            do
                args="$args $xx"
            done
            break
            ;;
  esac
done

if [ $doinit -gt 0 ]; then
    # Setup repo structure

    [ -d $PWD/src ]        || mkdir -p $PWD/src
    [ -d $PWD/vendor/src ] || mkdir -p $PWD/vendor/src

    touch vendor/manifest.txt
    ign=$PWD/.gitignore

    [ -f $ign ] || touch $ign
    if ! grep -q vendor/src $ign; then
        cat >> $ign <<EOFx

# gg vendor management
vendor/src/*
vendor/pkg/*
EOFx
    fi

    gitx add vendor/manifest.txt .gitignore
    exit 0
fi

[ $Dryrun  -gt 0 ] && e=echo
[ $Verbose -gt 0 ] && Gitquiet=
[ $Debug   -gt 0 ] && set -x


set -- $args
cmd=$1; shift
[ -z "$cmd" ] && die "Insufficient arguments.. Try '$0 --help'"

if [ -n "$Arch" ]; then
    os=${Arch%%-*}
    cpu=${Arch##*-}
    [ "$os" = "$cpu" ] && cpu=$(go env GOHOSTARCH)

    o=${oses[$os]}
    c=${cpus[$cpu]}
    [ -z "$o" ] && die "Don't know anything about OS $os"
    [ -z "$c" ] && die "Don't know anything about CPU $cpu"

    export GOOS=$os GOARCH=$c
    if [ -n "${cgo[$os]}" ]; then
        export CGO_ENABLED=1

        # See if we have a specific cross-compiler for this CPU+OS combo
        xcc="${GOOS}_${GOARCH}"
        xcc=${!xcc}
        if [ -n "$xcc" ]; then
            p=`type -p $xcc`
            [ -n "$p" ] || die "Can't find $xcc! Do you have compilers for $GOARCH available in PATH?"
            export CC=$xcc
        else
            echo "$Z: No Cross compiler defined for $GOOS-$GOARCH. Build may fail.." 1>&2
        fi
    fi
fi


vendor=$PWD/vendor
export GOPATH=$vendor:$PWD
[ -f $vendor/manifest.txt ] || touch $vendor/manifest.txt

case $cmd in

    fetch|get)
        repo=$1
        [ -n "$repo" ] || die "missing repo name for fetch"

        fetch $vendor $repo
        ;;

    update)
        repo=$1
        tag=$2
        [ -n "$repo" ] || die "missing repo name for update"
        if [ "$repo" = "--all" ]; then
            update_all $vendor
        else
            update_one $vendor $repo $tag
        fi
        ;;

    rebuild)
        rebuild_manifest $vendor
        ;;

    sync)
        sync_all $vendor
        ;;

    list)
        list_all $vendor
        ;;

    *)  # We just pass it off to go..
        $e eval exec go $cmd "$@"
        ;;
esac
